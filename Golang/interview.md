# Golang

## 1. 基础面试题

### 1.1 与其他语言相比，Golang有什么好处

### 1.2 什么是协程

### 1.3 协程，线程和进程的区别

### 1.4 Golang 中 make 和 new 的区别

### 1.5 Golang 中数组和切片的区别

### 1.6 使用for range时， 迭代变量的地址回发生变化吗

### 1.7 如何高效拼接字符串

### 1.8 defer的执行顺序是怎样的， defer的作用或使用场景是什么

### 1.9 什么是rune类型

### 1.10 Golang tag有什么作用

### 1.11 Golang 打印 %v %+v %#v 有什么区别

### 1.12 Golang中 空struct{} 占用空间吗

### 1.13 Golang中 空struct{} 有什么用

### 1.14 init 函数什么时候执行

### 1.15 2个interface{} 可以比较吗

### 1.16 2个nil可能不相等吗

### 1.17 Golang中传参是值类型还是引用类型

### 1.18 如何知道一个对象是分配在栈上还是堆上

### 1.19 Golang中 函数多返回值是如何实现的

### 1.20 Golang中，_ 的作用

### 1.21 Golang中，普通指针和unsafe.Pointer有什么区别

### 1.22 unsafe.Pointer 和 uintptr 有什么区别和联系

## 2. Slice 面试题

### 2.1 slice 底层结构是怎样的

### 2.2 Golang中 slice是如何扩容的

### 2.3 从一个切片截取另一个切片，修改新切片的值会影响原来的切片内容吗

### 2.4 slice 作为函数参数传递，会改变原来的slice吗

## 3. Map面试题

### 3.1 Golang中， map的底层实现原理

### 3.2 Golang中， map遍历是否有序

### 3.3 Golang中， map为什么要设计成无序的

### 3.4 Golang中， Map 如何顺序读取

### 3.5 Golang中，Map 是否并发安全

### 3.6 Golang中，map的key一定是可比较的吗，为什么

### 3.7 Golang中，map的扩容时机是怎样的

### 3.8 Golang中，map扩容过程

### 3.9 Golang中，可以对map的元素取地址吗

### 3.10 Golang中，map删除一个key，会立刻释放内存吗

### 3.11 map 可以边遍历，边删除吗

## 4. channel面试题

### 4.1 什么是 CSP

### 4.2 Channel 底层实现原理

### 4.3 向channel发送数据的过程

### 4.4 从channel读取数据的过程

### 4.5 从一个已关闭的channel 读取数据，会发生什么

### 4.6 channel在什么情况下会引起内存泄漏

### 4.7 关闭channel会产生异常吗

### 4.8 向一个关闭的channel会发生什么

### 4.9 什么是select

### 4.10 select的执行机制

### 4.11 select实现原理

## 5. Sync 面试题

### 5.1 除了mutex， 还有哪些方式可以安全的读写共享变量

### 5.2 Golang是如何实现原子操作的

### 5.3 原子操作和锁的区别

### 5.4 Golang中，mutex的底层实现原理

### 5.5 mutex有几种模式

### 5.6 在mutex上自旋会占用太多资源吗

### 5.7 mutex已经被一个goroutine获取，mutex被释放后等待中的goroutine哪一个会优先获取到mutex

### 5.8 sync.Once 作用，详细描述实现原理

### 5.9 wiatGroup 怎么实现协程等待

### 5.10 snyc.Map 实现原理

### 5.11 read map 和 dirty map之间有什么联系

### 5.12 为什么设计nil 和 expunged两种状态

### 5.13 sync.map 使用场景

## 6. Context 面试题

### 6.1 Golang中，Context是什么

### 6.2 Golang中，Context有什么作用

### 6.3 Context.Value 的查找过程是怎样的

### 6.4 Context如何被取消

## 7. Interface 面试题

### 7.1 Golang中，interface底层实现原理

### 7.2 iface 和 eface区别

### 7.3 类型转换和断言的区别是什么

### 7.4 Golang中，interface的使用场景

### 7.5 接口之间可以互相比较吗

## 8. 反射面试题

### 8.1 什么是反射

### 8.2 Golang如何实现反射

### 8.3 Golang中的反射应用有哪些

### 8.4 如何比较两个对象完全相同

## 9. GMP 面试题

### 9.1 Golang中的GMP模型是什么

### 9.2 什么是 GO Scheduler

### 9.3 Go语言在进行goroutine 调度的时候，调度策略是怎样的

### 9.4 发生调度的时机有哪些

### 9.5 M寻找G的过程是怎样的

### 9.6 GMP 能不能去掉P层，去掉之后会怎样

### 9.7 P和M 在什么时候会被创建

### 9.8 m0是什么，有什么作用

### 9.9 g0 是什么，有什么作用

### 9.10 g0栈和 用户栈是如何进行切换的

## 10. 内存管理

### 10.1 Golang是如何分配内存的

### 10.2 Golang内存逃逸是什么，什么情况下会发生内存逃逸

### 10.3 Golang内存逃逸有什么影响

### 10.4 channel是分配在堆上还是栈上

### 10.5 Golang在什么情况下发生内存泄漏

### 10.6 Golang发生内存泄漏，如何定位和优化

## 11. GC面试题

### 11.1 常见的GC方式有哪些

### 11.2 Golang GC 使用的是什么

### 11.3 三色标记法是什么

### 11.4 Golang GC的根对象到底是什么

### 11.5 STW是什么意思

### 11.6 并发标记清除法的难点是什么

### 11.7 Golang是如何解决并发标记清除时，用户程序并发修改对象引用问题的

### 11.8 什么是写屏障，混合写屏障，如何实现

### 11.9 Golang中，GC的流程是什么

### 11.10 GC触发的时机有哪些

### 11.11 GC关注的指标有哪些

### 11.12 有了GC，为什么还会发生内存泄漏

### 11.13 Golang GC 如何调优

### 11.14 如何观察Go GC

## 12. 代码面试题

### 12.1 开启100 个协程，顺序打印1-1000，且保证协程号1的，打印尾数为1 的数字

### 12.2 三个goroutine 交替打印abc 三次

### 12.3 用不超过10个goroutine 不重复的打印slice的100个元素

### 12.4 两个协程交替打印奇偶数

### 12.5 用单个channel实现0，1 的交替打印

### 12.6 sync.Cond 实现多生产者，多消费者

### 12.7 使用go实现1000个并发控制并设置执行超时时间为1s

### 12.8 使用两个goroutine, 向标准输出中按顺序交替打印字母与数字，输出是a1b2c3

### 12.9 写一个程序限制10个goroutine执行，每执行完一个goroutine就放一个goroutine进来
